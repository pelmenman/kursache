### 2.1.4 Z-функция
Пусть дана строка S длины n. Z-функция от строки — это массив длины n, i-ый элемент которого равен наибольшому числу символов, которые совпадают с префиксом строки S, начиная с позиции i. Значение Z-функции в нулевой позиции равен или нулю, или длине всей строки. Z-функция может использоваться вместо префикс-функции в алгоритме Кнута-Морриса-Пратта, который был рассмотрен ранее.


Тривиально Z-функция вычисляется так:

Для каждой позиции i значение z[i] увеличивается до тех пор, пока не обнаружится несоответствие или пока алгоритм не дойдет до конца строки.

Чтобы эффективно вычислять значения Z-функции, необходимо это делать по очереди от 1 до n-1. Назовём подстроку, которая совпадает с префиксом строки S, отрезком совпадения. Так, значением Z-функции является длиннейший отрезок совпадения, который начинается в позиции i и заканчивается в позиции i + z[i] - 1. Далее понадобятся координаты отрезка совпадения [l; r], заканчивающегося позже всех. Можно сказать, что r — индекс, до которого алгоритм уже успел дойти.

При подсчёте значения Z-функции для индекса i стоит рассмотреть следующие случаи:

1. i > r — нынешняя позиция расположена за пределами той части строки, которую уже успели проверить. Тогда стоит воспользоваться тривиальным алгоритмом, который описан выше; если z[i] > 0, то значение r меняется: r = i + z[i] - 1. 
2. i <= r — нынешняя позиция находится в пределах отрезка совпадения. В таком случае можно использовать уже посчитанные значения Z-функции, чтобы проинициализировать значение z[i] числом, отличного от нуля. Стоит также отметить, что подстроки s[l...r] и s[0...r-l] совпадают, что означает, что для приближённого значения для z[i] можно взять значение из z[i-l], однако важно заметить, что значение z[i-l] может оказаться большим и i выйдет за пределы r, чего допускать нельзя: символы, находящиеся правее r, ещё не были проверены. Пример такой ситуации:

    Пусть дана строка "aaaabaa". Если дойти до позиции i = 6, самым правым отрезком будет [5;6]. Таким образом, z[6], с учётом рассуждений, описанных выше, будет соответствовать z[1] = 3 (6 - 5 = 1; z[1] = 3). Очевидно, что ответ совершенно некорректный: z[6] соответствует 1, так как это наибольшее значение, находящееся в пределах [l; r]. 
  
    Так, приближённое значение вычисляется: z[i] = min(r - i+1, z[i-l]).
  
 Таким образом, алгоритм рассматривает два случая, которые отличаются только начальным значением z[i]: в первом случае оно равно нулю, а во втором — определяется формулой, упомянутой ранее. Рассмотрев тот или иной случай, алгоритм сводится к выполнению тривиального и работает за линейное время.
